#include <map>
#include "skeleton.h"

char SkeletonPass::ID = 0;

// key: address of malloc instruction
// value: size of the array
std::map<Value *, Value *> addressSizeMap;

static void registerSkeletonPass(const PassManagerBuilder &, legacy::PassManagerBase &PM)
{
    // you need to add other pass to use it in the your own pass.
    // For example,

    // You only need to add the above code when necessary.

    // You must write the below code
    PM.add(new SkeletonPass());
}

void SkeletonPass::getAnalysisUsage(AnalysisUsage &AU) const
{
    // you need to add other pass to use it in the your own pass.
    // For example,

    // You only need to add the function when necessary.
}

bool SkeletonPass::runOnModule(Module &M)
{
    // DataLayout: A parsed version of the target data layout string in and methods for querying it
    // EmitGEPOffset 인자
    // DL = &M.getDataLayout();
    DataLayout DL = M.getDataLayout();

    errs() << "------------------------------------------------------------------------------";
    for (Function &F : M)
    {
        if (F.hasName())
        {
            errs() << "\nFunction name is... " << F.getName() << "\n";
        }

        for (BasicBlock &B : F)
        {
            for (Instruction &I : B)
            {

                errs() << "\n>> this instruction is ..." << I << "\n";

                // 1) Alloca
                if (AllocaInst *AI = dyn_cast<AllocaInst>(&I))
                {
                    // pointer
                    if (AI->getAllocatedType()->isPointerTy())
                    {
                        IRBuilder<> irb(AI);
                        AllocaInst *newAI = irb.CreateAlloca(irb.getInt32Ty(), nullptr);
                        addressSizeMap[dyn_cast<Value>(AI)] = dyn_cast<Value>(newAI);
                        errs() << "pointer is allocated\n";
                        errs() << dyn_cast<Value>(AI) << ", " << dyn_cast<Value>(newAI) << "\n";
                    }

                    // array
                    if (AI->getAllocatedType()->isArrayTy())
                    {
                        IRBuilder<> irb(AI);
                        AllocaInst *newAI = irb.CreateAlloca(irb.getInt32Ty(), nullptr);

                        ArrayType *arraytype = dyn_cast<ArrayType>(AI->getAllocatedType());
                        Value *arraysize = ConstantInt::get(irb.getInt32Ty(), arraytype->getArrayNumElements());
                        errs() << "arraysize: " << *arraysize << "\n";

                        addressSizeMap[dyn_cast<Value>(AI)] = arraysize;

                        // addressSizeMap[dyn_cast<Value>(AI)] = dyn_cast<Value>(newAI);
                        // errs() << "array is allocated\n";
                        // errs() << dyn_cast<Value>(AI) << ", " << dyn_cast<Value>(newAI) << "\n";
                    }
                }

                // 2) GEP
                if (GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(&I))
                {
                    errs() << "gep instruction! ! ! !\n";

                    IRBuilder<> irb(GEPI);
                    Value *offset = EmitGEPOffset(&irb, DL, GEPI, true);

                    errs() << "offset: " << *offset << "\n\n";
                    // *offset:  i64 4*(index)

                    // GEP instruction -> Store instruction
                    Instruction *next = I.getNextNode();
                    errs() << "next: " << *next << "\n";

                    if (StoreInst *SI = dyn_cast<StoreInst>(next))
                    {
                        errs() << "gep -> store !!! found it!\n";
                        errs() << "우리가 저장했던 key allca inst: " << *(GEPI->getPointerOperand()) << "\n";

                        if (addressSizeMap.count(GEPI->getPointerOperand()))
                        {
                            Value *arraySize = addressSizeMap[GEPI->getPointerOperand()];
                            Value *offsetSize = offset;

                            errs() << "arraySize: " << *arraySize << "\n";
                            errs() << "offsetSize: " << *offsetSize << "\n";
                            // arraySize: i32 3, offsetSize: i64 16 (왜 int 크기 다른지는 모르겠지만 일단~)

                            // 여기에서 이제 외부 함수 링크


                            // 아래 함수로 Instruction type([3 x i32]*) 구할 수는 있지만, Type 값이라 사용불가
                            // errs() << "getPointerOperandType: " << *(GEPI->getPointerOperandType()) << "\n";
                        }
                    }
                }

                // 3) Store
                else if (StoreInst *SI = dyn_cast<StoreInst>(&I))
                {
                    errs() << "store instruction!\n";
                }

                // 4) Call malloc
                if (CallInst *CI = dyn_cast<CallInst>(&I))
                {
                    errs() << "Call inst! \n";
                    Function *calledF = cast<CallInst>(&I)->getCalledFunction();
                    if (calledF->getName() == "malloc")
                    {
                        errs() << "malloc !\n";

                        Value *size = CI->getArgOperand(0);
                        errs() << "size: " << *(CI->getOperand(0)) << "\n";

                        Instruction *next = I.getNextNode();
                        errs() << "next: " << *next << "\n";

                        errs() << CI->getNumOperands() << "\n";

                        if (StoreInst *SI = dyn_cast<StoreInst>(next))
                        {
                            Value *ptr = SI->getPointerOperand();
                            errs() << "*ptr: " << *ptr << "\n";
                            errs() << "ptr: " << ptr << "\n";

                            if (isa<AllocaInst>(ptr))
                            {
                                // IRBuilder<> irb(SI);
                                // irb.CreateStore(size, allocaSize);
                                // addressSizeMap[ptr] = allocaSize;
                            }
                        }
                    }
                }
            }
        }
    }
    return false;
}
static RegisterPass<SkeletonPass> SKELETONPASS("skeleton", "It is skeleton pass");
