#include <map>
#include "skeleton.h"

char SkeletonPass::ID = 0;

// key: address of malloc instruction
// value: size of the array
std::map<Value *, Value *> addressSizeMap;

static void registerSkeletonPass(const PassManagerBuilder &, legacy::PassManagerBase &PM)
{
    // you need to add other pass to use it in the your own pass.
    // For example,

    // You only need to add the above code when necessary.

    // You must write the below code
    PM.add(new SkeletonPass());
}

void SkeletonPass::getAnalysisUsage(AnalysisUsage &AU) const
{
    // you need to add other pass to use it in the your own pass.
    // For example,

    // You only need to add the function when necessary.
}

bool SkeletonPass::func()
{
}

bool SkeletonPass::runOnModule(Module &M)
{
    // DataLayout: A parsed version of the target data layout string in and methods for querying it
    // EmitGEPOffset 인자
    // DL = &M.getDataLayout();

    for (Function &F : M)
    {
        if (F.hasName())
        {
            errs() << "Function name is... " << F.getName() << "\n";
        }

        for (Instruction &I : instructions(F))
        {

            // AllocaInst *AI = dynamic_cast<AllocaInst>(I);
            // if (AI != NULL)

            // 1) 정상적으로 선언된 배열
            // 스택 할당하는 inst(AllocaInst) 찾아서 그중에 배열 할당인 얘들만 걸러줌

            // find instruction that allocates memory (stack)
            if (AllocaInst *AI = dyn_cast<AllocaInst>(&I))
            {

                // pointer 타입으로 할당된 변수도 찾아줌

                if (AI->getAllocatedType()->isPointerTy())
                {
                    // pointer에 할당된 버퍼 크기는 malloc할 때 알게됨
                    // 그럼 여기서는 key만 가져가면 될듯???
                    IRBuilder<> irb(AI);
                    AllocaInst *newAI = irb.CreateAlloca(irb.getInt32Ty(), nullptr);
                    addressSizeMap[dyn_cast<Value>(AI)] = dyn_cast<Value>(newAI);

                    // 이 코드는 에러 났는데 왜 위에 방식은 에러가 안나지? insert 뭐가 문제?
                    // addressSizeMap.insert(dyn_cast<Value>(AI), dyn_cast<Value>(newAI));
                }

                // int[i]; // isArrayAllocation()
                // int[4]; // isArrayAllocation() -> False() , ArrayTy
                if (AI->getAllocatedType()->isArrayTy())
                {
                    Type *type = AI->getAllocSkeletonPass

                                 else if (CallInst *CI = dyn_cast<CallInst>(&I))
                    {
                        // get the function called by call instruction
                        Function *calledF = cast<CallInst>(&I)->getCalledFunction();

                        // debugging output
                        errs() << "Called Func Name : " << calledF->getName() << "\n";

                        if (calledF->getName() == "malloc") // calledF->getName() == "_Znwm" : _Znwm는 free라고함
                        {
                            // debugging output
                            errs() << "Dynamic memory allocation!\n";

                            // CallInst의 ArgOperand로 인자 가져오기
                            Value *size = CI->getArgOperand(0);
                            Instruction *next = I.getNextNode();

                            errs() << CI->getNumOperands() << "\n";
                            errs() << CI->getOperand(0) << "\n";

                            // StoreInst ???
                            if (StoreInst *SI = dyn_cast<StoreInst>(next))
                            {
                                Value *ptr = SI->getPointerOperand();
                                if (isa<AllocaInst>(ptr))
                                {
                                    IRBuilder<> irb(SI);
                                    AllocaInst *allocaSize = irb.CreateAlloca(Type::getInt32Ty(SI->getContext()), nullptr);
                                    irb.CreateStore(size, allocaSize);
                                    addressSizeMap.insert({ptr, allocaSize});

                                    // get the size of array
                                    Value *size = ai->getArraySize();

                                    // save address-size data in map
                                    addressSizeMap.insert({AI, size});
                                }
                            }
                        }
                    }
                    // i8 ./build/lib/libSkeletonPass.so
                }
            }
            
        }
    }
    return false;
}
static RegisterPass<SkeletonPass> SKELETONPASS("skeleton", "It is skeleton pass");
