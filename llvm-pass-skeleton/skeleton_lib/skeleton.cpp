#include <map>
#include "skeleton.h"

char SkeletonPass::ID = 0;

// key: address of malloc instruction
// value: size of the array
std::map<Value *, Value *> addressSizeMap;

static void registerSkeletonPass(const PassManagerBuilder &, legacy::PassManagerBase &PM)
{
    // you need to add other pass to use it in the your own pass.
    // For example,

    // You only need to add the above code when necessary.

    // You must write the below code
    PM.add(new SkeletonPass());
}

void SkeletonPass::getAnalysisUsage(AnalysisUsage &AU) const
{
    // you need to add other pass to use it in the your own pass.
    // For example,

    // You only need to add the function when necessary.
}

bool SkeletonPass::runOnModule(Module &M)
{
    // DataLayout: A parsed version of the target data layout string in and methods for querying it
    // EmitGEPOffset 인자
    // DL = &M.getDataLayout();
    DataLayout DL = M.getDataLayout();

    errs() << "------------------------------------------------------------------------------";
    for (Function &F : M)
    {
        if (F.hasName())
        {
            errs() << "\nFunction name is... " << F.getName() << "\n";
        }

        for (BasicBlock &B : F)
        {
            for (Instruction &I : B)
            {
                
                // errs() << "\n>> this instruction is ..." << I << "\n";

                // 1) Alloca
                if (AllocaInst *AI = dyn_cast<AllocaInst>(&I))
                {
                    // pointer
                    if (AI->getAllocatedType()->isPointerTy())
                    {
                        IRBuilder<> irb(AI);
                        AllocaInst *newAI = irb.CreateAlloca(irb.getInt32Ty(), nullptr);
                        addressSizeMap[dyn_cast<Value>(AI)] = dyn_cast<Value>(newAI);
                        errs() << "pointer is allocated\n";
                        errs() << dyn_cast<Value>(AI) << ", " << dyn_cast<Value>(newAI) << "\n";
                    }

                    // array
                    if (AI->getAllocatedType()->isArrayTy())
                    {
                        IRBuilder<> irb(AI);
                        AllocaInst *newAI = irb.CreateAlloca(irb.getInt32Ty(), nullptr);
                        addressSizeMap[dyn_cast<Value>(AI)] = dyn_cast<Value>(newAI);
                        errs() << "array is allocated\n";
                        errs() << dyn_cast<Value>(AI) << ", " << dyn_cast<Value>(newAI) << "\n";
                    }
                }

                // 2) GEP
                else if (GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(&I)){
                    errs() << "gep instruction! ! ! !\n";

                    IRBuilder<> irb(GEPI);
                    Value *offset = EmitGEPOffset(&irb, DL, GEPI, true);

                    errs() << "offset: " << *offset << "\n";

                    // *offset:  i64 4*(index)
                    // errs() << dyn_cast<ConstantInt>(*offset) / dyn_cast<ConstantInt>(4) << "\n";
                    
                    // Value type으로 바로 산술 연산이 되나? -> 애초에 Value 타입 변수에 int값 안담김
                    // int to Value casting도 안됨
                    // errs() << *offset / dyn_cast<Value*>(4) <<"\n";

                    // 이거 해결책을 찾아왔는데, 그냥 바이트로 계산하면 된다 ! 오 왜 그생각을 못했지
                    
                }


                else if (StoreInst *SI = dyn_cast<StoreInst>(&I))
                {
                    errs() << "store instruction!\n";
                }

                if (CallInst *CI = dyn_cast<CallInst>(&I))
                {
                    Function *calledF = cast<CallInst>(&I)->getCalledFunction();
                    if (calledF->getName() == "malloc")
                    {
                        Value *size = CI->getArgOperand(0);
                        errs() << "size: " << CI->getOperand(0) << "\n";
                        Instruction *next = I.getNextNode();
                        errs() << "next: " << *next << "\n";

                        errs() << CI->getNumOperands() << "\n";

                        if (StoreInst *SI = dyn_cast<StoreInst>(next))
                        {
                            Value *ptr = SI->getPointerOperand();
                            errs() << "*ptr: " << *ptr << "\n";
                            errs() << "ptr: " << ptr << "\n";

                            if (isa<AllocaInst>(ptr))
                            {
                                IRBuilder<> irb(SI);
                                AllocaInst *allocaSize = irb.CreateAlloca(Type::getInt32Ty(SI->getContext()), nullptr);
                                irb.CreateStore(size, allocaSize);
                                addressSizeMap[ptr] = allocaSize;
                            }
                        }
                    }
                }
            }
        }
    }
    return false;
}
static RegisterPass<SkeletonPass> SKELETONPASS("skeleton", "It is skeleton pass");
