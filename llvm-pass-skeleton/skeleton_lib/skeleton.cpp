#include <map>
#include "skeleton.h"

char SkeletonPass::ID = 0;

// key: address of malloc instruction
// value: size of the array
std::map<Value *, Value *> addressSizeMap;

static void registerSkeletonPass(const PassManagerBuilder &, legacy::PassManagerBase &PM)
{
    // you need to add other pass to use it in the your own pass.
    // For example,

    // You only need to add the above code when necessary.

    // You must write the below code
    PM.add(new SkeletonPass());
}

void SkeletonPass::getAnalysisUsage(AnalysisUsage &AU) const
{
    // you need to add other pass to use it in the your own pass.
    // For example,

    // You only need to add the function when necessary.
}

bool SkeletonPass::runOnModule(Module &M)
{
    // DataLayout: A parsed version of the target data layout string in and methods for querying it
    // EmitGEPOffset 인자
    // DL = &M.getDataLayout();
    DataLayout DL = M.getDataLayout();

    std::vector<Type *> plist;
    plist.push_back(Type::getInt32Ty(M.getContext()));
    plist.push_back(Type::getInt32Ty(M.getContext()));
    FunctionType *CompareFunctionType = FunctionType::get(Type::getInt32Ty(M.getContext()), plist, false);
    Function *compareFunc = Function::Create(CompareFunctionType, Function::ExternalLinkage, "compareOffsetNSize", &M);

    errs() << "------------------------------------------------------------------------------";
    for (Function &F : M)
    {
        if (F.hasName())
        {
            errs() << "\nFunction name is... " << F.getName() << "\n";
        }

        for (BasicBlock &B : F)
        {
            for (Instruction &I : B)
            {

                errs() << "\n>> this instruction is ..." << I << "\n";

                // 1) Alloca
                if (AllocaInst *AI = dyn_cast<AllocaInst>(&I))
                {
                    // pointer
                    if (AI->getAllocatedType()->isPointerTy())
                    {
                        IRBuilder<> irb(AI);
                        AllocaInst *newAI = irb.CreateAlloca(irb.getInt32Ty(), nullptr);
                        addressSizeMap[dyn_cast<Value>(AI)] = dyn_cast<Value>(newAI);
                        errs() << "pointer is allocated\n";
                        errs() << dyn_cast<Value>(AI) << ", " << dyn_cast<Value>(newAI) << "\n";
                    }

                    // array
                    if (AI->getAllocatedType()->isArrayTy())
                    {
                        IRBuilder<> irb(AI);
                        AllocaInst *newAI = irb.CreateAlloca(irb.getInt32Ty(), nullptr);

                        ArrayType *arraytype = dyn_cast<ArrayType>(AI->getAllocatedType());
                        Value *arraysize = ConstantInt::get(irb.getInt32Ty(), arraytype->getArrayNumElements());
                        errs() << "arraysize: " << *arraysize << "\n";

                        addressSizeMap[dyn_cast<Value>(AI)] = arraysize;
                    }
                }

                // 2) GEP
                if (GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(&I))
                {
                    errs() << "gep instruction! ! ! !\n";

                    IRBuilder<> irb(GEPI);
                    Value *offset = EmitGEPOffset(&irb, DL, GEPI, true);
                    // *offset:  i64 4*(index)

                    // GEP instruction -> Store instruction
                    Instruction *next = I.getNextNode();
                    errs() << "next: " << *next << "\n";

                    if (StoreInst *SI = dyn_cast<StoreInst>(next))
                    {
                        errs() << "gep -> store !!! found it!\n";
                        errs() << "우리가 저장했던 key alloca inst: " << *(GEPI->getPointerOperand()) << "\n";

                        if (addressSizeMap.count(GEPI->getPointerOperand()))
                        {
                            Value *arraySize = addressSizeMap[GEPI->getPointerOperand()];
                            Value *offsetSize = offset;

                            errs() << "arraySize: " << *arraySize << "\n";
                            errs() << "offsetSize: " << *offsetSize << "\n";
                            // arraySize: i32 3, offsetSize: i64 16

                            offsetSize = irb.CreateIntCast(offset, Type::getInt32Ty(offset->getContext()), true);
                            errs() << "offsetSize: " << *offsetSize << "\n";

                            IRBuilder<> irb(SI);
                            Value *funcOp1 = offsetSize;
                            Value *funcOp2 = arraySize;

                            std::vector<Value *> paramList;
                            paramList.push_back(funcOp1);
                            paramList.push_back(funcOp2);

                            Value *createdCallInst = irb.CreateCall(compareFunc, paramList);
                        }
                    }
                }

                // 3) Store
                else if (StoreInst *SI = dyn_cast<StoreInst>(&I))
                {
                    errs() << "store instruction!\n";
                }

                // 4) Call malloc
                if (CallInst *CI = dyn_cast<CallInst>(&I))
                {
                    errs() << "Call inst! \n";
                    Function *calledF = cast<CallInst>(&I)->getCalledFunction();
                    if (calledF->getName() == "malloc")
                    {
                        errs() << "malloc !\n";

                        Value *size = CI->getArgOperand(0);
                        errs() << "size: " << *(CI->getOperand(0)) << "\n";

                        Instruction *next = I.getNextNode();
                        errs() << "next: " << *next << "\n";

                        errs() << CI->getNumOperands() << "\n";

                        if (StoreInst *SI = dyn_cast<StoreInst>(next))
                        {
                            Value *ptr = SI->getPointerOperand();
                            errs() << "*ptr: " << *ptr << "\n";
                            errs() << "ptr: " << ptr << "\n";

                            if (isa<AllocaInst>(ptr))
                            {
                                // IRBuilder<> irb(SI);
                                // irb.CreateStore(size, allocaSize);
                                // addressSizeMap[ptr] = allocaSize;
                            }
                        }
                    }
                }
            }
        }
    }
    return false;
}
static RegisterPass<SkeletonPass> SKELETONPASS("skeleton", "It is skeleton pass");
