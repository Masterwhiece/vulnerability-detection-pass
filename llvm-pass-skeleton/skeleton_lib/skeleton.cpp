#include <map>
#include "skeleton.h"

char SkeletonPass::ID = 0;

// key: address of malloc instruction
// value: size of the array
std::map<Value *, Value *> addressSizeMap;

static void registerSkeletonPass(const PassManagerBuilder &, legacy::PassManagerBase &PM)
{
    // you need to add other pass to use it in the your own pass.
    // For example,

    // You only need to add the above code when necessary.

    // You must write the below code
    PM.add(new SkeletonPass());
}

void SkeletonPass::getAnalysisUsage(AnalysisUsage &AU) const
{
    // you need to add other pass to use it in the your own pass.
    // For example,

    // You only need to add the function when necessary.
}

bool SkeletonPass::runOnModule(Module &M)
{
    // DataLayout: A parsed version of the target data layout string in and methods for querying it
    // EmitGEPOffset 인자
    // DL = &M.getDataLayout();
    DataLayout DL = M.getDataLayout();

    errs() << "------------------------------------------------------------------------------";
    for (Function &F : M)
    {
        if (F.hasName())
        {
            errs() << "\nFunction name is... " << F.getName() << "\n";
        }


        for (BasicBlock &B : F)
        {
            for (Instruction &I : B)
            {
                
                errs() << "\n>> this instruction is ..." << I << "\n";

                // 1) Alloca
                if (AllocaInst *AI = dyn_cast<AllocaInst>(&I))
                {
                    // pointer
                    if (AI->getAllocatedType()->isPointerTy())
                    {
                        IRBuilder<> irb(AI);
                        AllocaInst *newAI = irb.CreateAlloca(irb.getInt32Ty(), nullptr);
                        addressSizeMap[dyn_cast<Value>(AI)] = dyn_cast<Value>(newAI);
                        errs() << "pointer is allocated\n";
                        errs() << dyn_cast<Value>(AI) << ", " << dyn_cast<Value>(newAI) << "\n";
                    }

                    // array
                    if (AI->getAllocatedType()->isArrayTy())
                    {
                        IRBuilder<> irb(AI);
                        AllocaInst *newAI = irb.CreateAlloca(irb.getInt32Ty(), nullptr);

                        
                        ArrayType* at =dyn_cast<ArrayType> (AI->getAllocatedType());
                        at->getArrayNumElements();
                        Value* size = ConstantInt::get(irb.getInt32Ty(), at->getArrayNumElements());
                        errs() << *size << "\n";

                        addressSizeMap[dyn_cast<Value>(AI)] = dyn_cast<Value>(newAI);
                        errs() << "array is allocated\n";
                        errs() << dyn_cast<Value>(AI) << ", " << dyn_cast<Value>(newAI) << "\n";
                    }
                }
                

                // 2) GEP
                if (GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(&I)){
                    errs() << "gep instruction! ! ! !\n";
                    
                    IRBuilder<> irb(GEPI);
                    Value *offset = EmitGEPOffset(&irb, DL, GEPI, true);

                    errs() << "offset: " << *offset << "\n\n";
                    // *offset:  i64 4*(index)

                    // GEP instruction -> Store instruction
                    Instruction *next = I.getNextNode();
                    errs() << "next: " << *next << "\n";

                    if (StoreInst *SI = dyn_cast<StoreInst>(next))
                    {
                        errs() << "gep -> store !!! found it!\n";

                        errs() << "우리가 저장했던 key allca inst: " << *(GEPI->getPointerOperand())  << "\n";

                        if (addressSizeMap.count(GEPI->getPointerOperand()))
                        {

                            // 근데 갑자기 든 생각. 이걸 굳이 load로 할 필요가 있나?
                            // 그냥 원래 allocainst 찾았는데 그거 사용하면 안되나
                           

                            errs() << "getPointerOperandType: " << *(GEPI->getPointerOperandType()) << "\n";

                            Value *inst = irb.CreateLoad(addressSizeMap[GEPI->getPointerOperand()]);
                            Value *offsetSize = offset;

                            errs() << "allocsize: " << *inst << "\n";
                            errs() << "offsetSize: " << *offsetSize << "\n";
                            


                            // Value *size = irb.CreateLoad(allocSize)->getOperand(0);
                            
                        }
                    }

                }


                // 3) Store
                else if (StoreInst *SI = dyn_cast<StoreInst>(&I))
                {
                    errs() << "store instruction!\n";
                }


                // 4) Call malloc
                if (CallInst *CI = dyn_cast<CallInst>(&I))
                {
                    errs() << "Call inst! \n";
                    Function *calledF = cast<CallInst>(&I)->getCalledFunction();
                    if (calledF->getName() == "malloc")
                    {
                        errs() << "malloc !\n";

                        Value *size = CI->getArgOperand(0);
                        errs() << "size: " << *(CI->getOperand(0)) << "\n";

                        Instruction *next = I.getNextNode();
                        errs() << "next: " << *next << "\n";

                        errs() << CI->getNumOperands() << "\n";

                        if (StoreInst *SI = dyn_cast<StoreInst>(next))
                        {
                            Value *ptr = SI->getPointerOperand();
                            errs() << "*ptr: " << *ptr << "\n";
                            errs() << "ptr: " << ptr << "\n";

                            if (isa<AllocaInst>(ptr))
                            {
                                // IRBuilder<> irb(SI);
                                // irb.CreateStore(size, allocaSize);
                                // addressSizeMap[ptr] = allocaSize;
                            }
                        }
                    }
                }
            }
        }
    }
    return false;
}
static RegisterPass<SkeletonPass> SKELETONPASS("skeleton", "It is skeleton pass");
