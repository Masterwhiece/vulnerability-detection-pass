#include <map>
#include "skeleton.h"

char SkeletonPass::ID = 0;

// key: address of malloc instruction
// value: size of the array
std::map<Value *, Value *> addressSizeMap;

static void registerSkeletonPass(const PassManagerBuilder &, legacy::PassManagerBase &PM)
{
    // you need to add other pass to use it in the your own pass.
    // For example,

    // You only need to add the above code when necessary.

    // You must write the below code
    PM.add(new SkeletonPass());
}

void SkeletonPass::getAnalysisUsage(AnalysisUsage &AU) const
{
    // you need to add other pass to use it in the your own pass.
    // For example,

    // You only need to add the function when necessary.
}

bool SkeletonPass::runOnModule(Module &M)
{
    // DataLayout: A parsed version of the target data layout string in and methods for querying it
    // EmitGEPOffset 인자
    // DL = &M.getDataLayout();

    for (Function &F : M)
    {
        if (F.hasName())
        {
            errs() << "Function name is... " << F.getName() << "\n";
        }

        for (Instruction &I : instructions(F))
        {
            // 1)
            if (AllocaInst *AI = dyn_cast<AllocaInst>(&I))
            {
                // pointer
                if (AI->getAllocatedType()->isPointerTy())
                {
                    IRBuilder<> irb(AI);
                    AllocaInst *newAI = irb.CreateAlloca(irb.getInt32Ty(), nullptr);
                    addressSizeMap[dyn_cast<Value>(AI)] = dyn_cast<Value>(newAI);
                    errs() << "pointer allocated\n";
                    errs() << dyn_cast<Value>(AI) << ", " << dyn_cast<Value>(newAI) << "\n";
                }

                // array
                if (AI->getAllocatedType()->isArrayTy())
                {
                    if (CallInst *CI = dyn_cast<CallInst>(&I))
                    {
                        Function *calledF = cast<CallInst>(&I)->getCalledFunction();
                        if (calledF->getName() == "malloc")
                        {
                            Value *size = CI->getArgOperand(0);
                            errs() << CI->getOperand(0) << "\n";
                            Instruction *next = I.getNextNode();
                            errs() << "next: " << *next << "\n";

                            errs() << CI->getNumOperands() << "\n";
                            

                            if (StoreInst *SI = dyn_cast<StoreInst>(next))
                            {
                                Value *ptr = SI->getPointerOperand();
                                errs() << "*ptr: " << *ptr << "\n";
                                errs() << "ptr: " << ptr << "\n";

                                if (isa<AllocaInst>(ptr))
                                {
                                    IRBuilder<> irb(SI);
                                    AllocaInst *allocaSize = irb.CreateAlloca(Type::getInt32Ty(SI->getContext()), nullptr);
                                    irb.CreateStore(size, allocaSize);
                                    addressSizeMap[ptr] = allocaSize;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return false;
}
static RegisterPass<SkeletonPass> SKELETONPASS("skeleton", "It is skeleton pass");
